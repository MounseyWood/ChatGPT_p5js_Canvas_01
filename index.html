<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Scarf Drawing App</title>
    <style>
      /* Basic styling for layout */
      body {
        margin: 0;
        display: flex;
        background-color: #333;
        color: #fff;
        font-family: sans-serif;
      }
      #ui-panel {
        width: 280px;
        padding: 10px;
        box-sizing: border-box;
      }
      #canvas-container {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #000;
      }
      #myCanvas {
        background-color: #fff;
      }
      .tool-section {
        margin-bottom: 15px;
      }
      .tool-section label {
        display: block;
        margin-bottom: 5px;
      }
      button {
        margin: 2px 0;
      }
    </style>
  </head>
  <body>
    <!-- UI Panel (Left) -->
    <div id="ui-panel">
      <h2>Scarf Drawing App</h2>

      <!-- Colour Picker -->
      <div class="tool-section">
        <label for="colorPicker">Color:</label>
        <select id="colorPicker">
          <option value="#000000">Black</option>
          <option value="#FFFFFF">White</option>
          <option value="#FF0000">Red</option>
          <option value="#00FF00">Green</option>
          <option value="#0000FF">Blue</option>
        </select>
      </div>

      <!-- Brush Size -->
      <div class="tool-section">
        <label for="brushSizeSlider">Brush Size:</label>
        <input type="range" id="brushSizeSlider" min="1" max="100" value="10">
      </div>

      <!-- Tools: Brush / Eraser -->
      <div class="tool-section">
        <button id="brushToolBtn">Brush Tool</button>
        <button id="eraserToolBtn">Eraser</button>
      </div>

      <!-- Undo / Redo -->
      <div class="tool-section">
        <button id="undoBtn">Undo</button>
        <button id="redoBtn">Redo</button>
      </div>

      <!-- New / Import / Export Project -->
      <div class="tool-section">
        <button id="startNewBtn">Start New</button>
        <button id="importProjectBtn">Import Project</button>
        <button id="exportProjectBtn">Export Project</button>
      </div>

      <!-- Text Fill Options -->
      <div class="tool-section">
        <label for="textInput">Text Fill Content:</label>
        <input type="text" id="textInput" placeholder="Type your fill text...">
        
        <label for="textSizeInput">Text Size:</label>
        <input type="number" id="textSizeInput" min="5" max="200" value="20">
        
        <label for="textSpacingInput">Text Spacing:</label>
        <input type="number" id="textSpacingInput" min="1" max="100" value="25">
        
        <button id="textFillBtn">Fill Last Shape</button>
      </div>

      <!-- Export Image -->
      <div class="tool-section">
        <button id="exportPngBtn">Export PNG</button>
        <button id="exportJpgBtn">Export JPG</button>
        <button id="exportTiffBtn">Export TIFF</button>
      </div>

      <p style="font-size: 0.85em;">
        <strong>Tip:</strong> Hold <em>Shift</em> + drag to define a shape for text fill.
      </p>
    </div>

    <!-- Canvas Container (Right) -->
    <div id="canvas-container">
      <!-- p5.js Library -->
      <script src="https://cdn.jsdelivr.net/npm/p5@1.4.0/lib/p5.js"></script>
      <script>
        /*******************************************
         * SCARF DRAWING APP (p5.js)
         *******************************************/
        const CANVAS_SIZE = 7087; // ~90 cm @ 200 DPI
        let brushColor = '#000000';
        let brushSize = 10;
        let currentTool = 'brush'; // 'brush' or 'eraser'

        // Undo/Redo History
        let history = [];
        let historyIndex = -1;

        // For capturing shapes (to fill with text)
        let shapes = [];
        let shapePoints = [];
        let isDrawingShape = false;

        function setup() {
          // Create a large canvas
          let cnv = createCanvas(CANVAS_SIZE, CANVAS_SIZE);
          cnv.id('myCanvas');

          // If your machine struggles with large pixel densities, keep it at 1:
          pixelDensity(1);

          // Fill background white
          background(255);

          // Grab UI elements
          setupUI();

          // Save initial blank state
          saveState();
        }

        function draw() {
          // Brush or Eraser drawing
          if (mouseIsPressed && !isDrawingShape && isOnCanvas()) {
            if (currentTool === 'brush') {
              stroke(brushColor);
              strokeWeight(brushSize);
              line(pmouseX, pmouseY, mouseX, mouseY);
            } else if (currentTool === 'eraser') {
              stroke(255);
              strokeWeight(brushSize);
              line(pmouseX, pmouseY, mouseX, mouseY);
            }
          }
        }

        /*******************************************
         * MOUSE & SHAPE CAPTURE
         *******************************************/
        function mousePressed() {
          // Hold Shift to start capturing shape points
          if (keyIsDown(SHIFT) && isOnCanvas()) {
            shapePoints = [];
            isDrawingShape = true;
          }
        }

        function mouseDragged() {
          // If capturing shape, record points
          if (isDrawingShape && isOnCanvas()) {
            shapePoints.push({ x: mouseX, y: mouseY });
            // Optionally draw a preview line in real time
            if (shapePoints.length > 1) {
              let prev = shapePoints[shapePoints.length - 2];
              stroke(0, 255, 0);
              strokeWeight(1);
              noFill();
              line(prev.x, prev.y, mouseX, mouseY);
            }
          }
        }

        function mouseReleased() {
          if (isDrawingShape) {
            // Finalize shape
            shapes.push([...shapePoints]);
            isDrawingShape = false;
            saveState();
          } else if (isOnCanvas()) {
            // Finished a brush/eraser stroke
            saveState();
          }
        }

        // Check if mouse is within the canvas bounds
        function isOnCanvas() {
          return (mouseX >= 0 && mouseX < width && mouseY >= 0 && mouseY < height);
        }

        /*******************************************
         * UNDO/REDO
         *******************************************/
        function saveState() {
          historyIndex++;
          // If we've undone and now draw a new stroke, remove forward states
          if (historyIndex < history.length) {
            history.splice(historyIndex);
          }
          // Push current canvas snapshot
          history.push(get());
        }

        function undoAction() {
          if (historyIndex > 0) {
            historyIndex--;
            restoreState();
          }
        }

        function redoAction() {
          if (historyIndex < history.length - 1) {
            historyIndex++;
            restoreState();
          }
        }

        function restoreState() {
          clear();
          image(history[historyIndex], 0, 0);
        }

        /*******************************************
         * TEXT FILL FOR LAST SHAPE
         *******************************************/
        function textFillShape() {
          if (shapes.length === 0) return;

          let shape = shapes[shapes.length - 1];
          if (!shape || shape.length < 3) return;

          let textString = select('#textInput').value() || "@";
          let txtSize = parseInt(select('#textSizeInput').value());
          let spacing = parseInt(select('#textSpacingInput').value());
          let fillColor = brushColor; // Use the current brush color

          push();
          fill(fillColor);
          noStroke();
          textSize(txtSize);

          // Find bounding box of the shape
          let minX = Math.min(...shape.map(p => p.x));
          let maxX = Math.max(...shape.map(p => p.x));
          let minY = Math.min(...shape.map(p => p.y));
          let maxY = Math.max(...shape.map(p => p.y));

          // Fill shape with text in a grid
          for (let y = minY; y < maxY; y += spacing) {
            for (let x = minX; x < maxX; x += spacing) {
              if (pnpoly(shape, x, y)) {
                text(textString, x, y);
              }
            }
          }
          pop();

          saveState();
        }

        // Point-in-polygon test (pnpoly)
        // https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html
        function pnpoly(vertices, testx, testy) {
          let c = false;
          for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
            let xi = vertices[i].x, yi = vertices[i].y;
            let xj = vertices[j].x, yj = vertices[j].y;
            let intersect = ((yi > testy) != (yj > testy)) &&
              (testx < (xj - xi) * (testy - yi) / (yj - yi) + xi);
            if (intersect) c = !c;
          }
          return c;
        }

        /*******************************************
         * PROJECT IMPORT / EXPORT
         *******************************************/
        function importProject() {
          // Let user pick a JSON file
          let input = createFileInput(handleFile);
          input.elt.click(); // Programmatically open file dialog

          function handleFile(file) {
            if (file.type === 'application' || file.subtype === 'json') {
              let data = JSON.parse(file.data);
              // Restore image
              loadImage(data.image, img => {
                clear();
                image(img, 0, 0);
                // Reset history
                history = [];
                historyIndex = -1;
                saveState();
              });
              // Restore shapes if needed
              if (data.shapes) {
                shapes = data.shapes;
              }
            } else {
              alert("Please select a valid project JSON file.");
            }
          }
        }

        function exportProject() {
          // Export current canvas as base64 plus shape data
          let currentCanvas = get();
          let dataURL = currentCanvas.canvas.toDataURL();

          let projectData = {
            image: dataURL,
            shapes: shapes
          };

          let blob = new Blob([JSON.stringify(projectData)], { type: "application/json" });
          let url = URL.createObjectURL(blob);

          let a = createA(url, 'project.json');
          a.elt.download = 'project.json';
          a.elt.click();
        }

        /*******************************************
         * IMAGE EXPORT (PNG / JPG / TIFF)
         *******************************************/
        function exportImage(format) {
          if (format === 'png') {
            // p5.js built-in
            saveCanvas('myScarfDesign', 'png');
          } else if (format === 'jpg') {
            // p5.js built-in
            saveCanvas('myScarfDesign', 'jpg');
          } else if (format === 'tiff') {
            // p5.js doesn't natively export TIFF. 
            // Typically you'd export PNG/JPG, then convert externally
            alert("TIFF export isn't directly supported. Please export as PNG or JPG and convert if needed.");
          }
        }

        /*******************************************
         * SETUP UI
         *******************************************/
        function setupUI() {
          // Color Picker
          select('#colorPicker').changed(() => {
            brushColor = select('#colorPicker').value();
          });

          // Brush Size
          select('#brushSizeSlider').changed(() => {
            brushSize = select('#brushSizeSlider').value();
          });

          // Tool Buttons
          select('#brushToolBtn').mousePressed(() => {
            currentTool = 'brush';
          });
          select('#eraserToolBtn').mousePressed(() => {
            currentTool = 'eraser';
          });

          // Undo / Redo
          select('#undoBtn').mousePressed(undoAction);
          select('#redoBtn').mousePressed(redoAction);

          // Start New
          select('#startNewBtn').mousePressed(() => {
            let confirmNew = confirm("Start a new project? Unsaved work will be lost.");
            if (confirmNew) {
              background(255);
              history = [];
              historyIndex = -1;
              shapes = [];
              saveState();
            }
          });

          // Import / Export Project
          select('#importProjectBtn').mousePressed(importProject);
          select('#exportProjectBtn').mousePressed(exportProject);

          // Text Fill
          select('#textFillBtn').mousePressed(textFillShape);

          // Export Image
          select('#exportPngBtn').mousePressed(() => exportImage('png'));
          select('#exportJpgBtn').mousePressed(() => exportImage('jpg'));
          select('#exportTiffBtn').mousePressed(() => exportImage('tiff'));
        }
      </script>
    </div>
  </body>
</html>

