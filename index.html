<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>Scarf Drawing App - Smaller Canvas, High-Res Export</title>
    <style>
      body {
        margin: 0;
        display: flex;
        background-color: #333;
        color: #fff;
        font-family: sans-serif;
      }
      #ui-panel {
        width: 280px;
        padding: 10px;
        box-sizing: border-box;
      }
      #canvas-container {
        flex: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #000;
      }
      #myCanvas {
        background-color: #fff;
      }
      .tool-section {
        margin-bottom: 15px;
      }
      .tool-section label {
        display: block;
        margin-bottom: 5px;
      }
      button {
        margin: 3px 0;
        cursor: pointer;
      }
      input[type="range"] {
        width: 100%;
      }
    </style>
  </head>
  <body>
    <!-- UI Panel (Left) -->
    <div id="ui-panel">
      <h2>Scarf Drawing App</h2>

      <!-- Colour Picker -->
      <div class="tool-section">
        <label for="colorPicker">Color:</label>
        <select id="colorPicker">
          <option value="#000000">Black</option>
          <option value="#FFFFFF">White</option>
          <option value="#FF0000">Red</option>
          <option value="#00FF00">Green</option>
          <option value="#0000FF">Blue</option>
        </select>
      </div>

      <!-- Brush Size -->
      <div class="tool-section">
        <label for="brushSizeSlider">Brush Size:</label>
        <input type="range" id="brushSizeSlider" min="1" max="100" value="10" />
      </div>

      <!-- Tools: Brush / Eraser -->
      <div class="tool-section">
        <button id="brushToolBtn">Brush Tool</button>
        <button id="eraserToolBtn">Eraser</button>
      </div>

      <!-- Undo / Redo -->
      <div class="tool-section">
        <button id="undoBtn">Undo</button>
        <button id="redoBtn">Redo</button>
      </div>

      <!-- Start New / Import / Export Project -->
      <div class="tool-section">
        <button id="startNewBtn">Start New</button>
        <button id="importProjectBtn">Import Project</button>
        <button id="exportProjectBtn">Export Project</button>
      </div>

      <!-- Text Fill Options -->
      <div class="tool-section">
        <label for="textInput">Text Fill Content:</label>
        <input type="text" id="textInput" placeholder="@ or # etc." />
        
        <label for="textSizeInput">Text Size:</label>
        <input type="number" id="textSizeInput" min="5" max="200" value="20" />
        
        <label for="textSpacingInput">Text Spacing:</label>
        <input type="number" id="textSpacingInput" min="1" max="100" value="25" />
        
        <button id="textFillBtn">Fill Last Shape</button>
      </div>

      <!-- Export Image -->
      <div class="tool-section">
        <button id="exportPngBtn">Export PNG</button>
        <button id="exportJpgBtn">Export JPG</button>
        <button id="exportTiffBtn">Export TIFF</button>
      </div>

      <p style="font-size: 0.85em;">
        <strong>Tip:</strong> Hold <em>Shift</em> + drag on the canvas to define a shape for text fill.
      </p>
    </div>

    <!-- Canvas Container (Right) -->
    <div id="canvas-container">
      <!-- p5.js Library -->
      <script src="https://cdn.jsdelivr.net/npm/p5@1.4.0/lib/p5.js"></script>
      <script>
        /******************************************************
         * SCARF DRAWING APP (Smaller Canvas, High-Res Export)
         ******************************************************/

        // Interactive canvas dimensions
        const INTERACTIVE_SIZE = 1000;

        // High-res export dimensions (approx 90cm at 200DPI)
        const EXPORT_SIZE = 7087;

        let brushColor = '#000000';
        let brushSize = 10;
        let currentTool = 'brush'; // 'brush' or 'eraser'

        // Actions array: each action is {type, color, size, points} or {type: 'fillShape', shape, ...}
        let actions = [];

        // Current stroke in progress
        let currentStroke = null;
        let isDrawingStroke = false;

        // Shape capture
        let tempShape = [];
        let isDrawingShape = false;

        // Undo/Redo History
        let history = [];
        let historyIndex = -1;

        function setup() {
          let cnv = createCanvas(INTERACTIVE_SIZE, INTERACTIVE_SIZE);
          cnv.id('myCanvas');
          pixelDensity(1); // Avoid high-DPI doubling

          background(255);

          // Initialize UI
          setupUI();

          // Save an initial empty state for undo/redo
          saveHistory();
        }

        function draw() {
          // Re-draw everything from actions each frame
          drawCanvas(1, this);
        }

        /******************************************************
         * Drawing the Canvas at a Given Scale
         ******************************************************/
        function drawCanvas(scaleFactor, p) {
          // p is the p5 instance/context to draw on
          p.background(255);

          // Replay each action
          for (let action of actions) {
            drawAction(action, p, scaleFactor);
          }

          // If currently drawing a stroke, draw the partial stroke
          if (isDrawingStroke && currentStroke && currentStroke.points.length > 1) {
            p.stroke(currentStroke.color);
            p.strokeWeight(currentStroke.size * scaleFactor);
            for (let i = 1; i < currentStroke.points.length; i++) {
              let prev = currentStroke.points[i - 1];
              let curr = currentStroke.points[i];
              p.line(prev.x * scaleFactor, prev.y * scaleFactor, curr.x * scaleFactor, curr.y * scaleFactor);
            }
          }

          // If currently drawing a shape, optionally draw a preview line
          if (isDrawingShape && tempShape.length > 1) {
            p.stroke('#0f0');
            p.strokeWeight(1 * scaleFactor);
            for (let i = 1; i < tempShape.length; i++) {
              let prev = tempShape[i - 1];
              let curr = tempShape[i];
              p.line(prev.x * scaleFactor, prev.y * scaleFactor, curr.x * scaleFactor, curr.y * scaleFactor);
            }
          }
        }

        // Draw a single action (stroke or shape fill) at scaleFactor
        function drawAction(action, p, scaleFactor) {
          if (action.type === 'stroke') {
            p.stroke(action.color);
            p.strokeWeight(action.size * scaleFactor);
            p.noFill();
            let pts = action.points;
            for (let i = 1; i < pts.length; i++) {
              let prev = pts[i - 1];
              let curr = pts[i];
              p.line(prev.x * scaleFactor, prev.y * scaleFactor, curr.x * scaleFactor, curr.y * scaleFactor);
            }
          } else if (action.type === 'fillShape') {
            fillShapeWithText(p, action.shape, action.text, action.color, action.textSize, action.spacing, scaleFactor);
          }
        }

        /******************************************************
         * Mouse & Shape Capture
         ******************************************************/
        function mousePressed() {
          if (!isOnCanvas()) return;

          if (keyIsDown(SHIFT)) {
            // Start capturing a shape
            isDrawingShape = true;
            tempShape = [{ x: mouseX, y: mouseY }];
          } else {
            // Start a brush or eraser stroke
            isDrawingStroke = true;
            currentStroke = {
              type: 'stroke',
              color: currentTool === 'eraser' ? '#FFFFFF' : brushColor,
              size: brushSize,
              points: [{ x: mouseX, y: mouseY }]
            };
          }
        }

        function mouseDragged() {
          if (!isOnCanvas()) return;

          if (isDrawingShape) {
            tempShape.push({ x: mouseX, y: mouseY });
          } else if (isDrawingStroke && currentStroke) {
            currentStroke.points.push({ x: mouseX, y: mouseY });
          }
        }

        function mouseReleased() {
          if (isDrawingShape) {
            isDrawingShape = false;
            // We just store the shape in tempShape; user can fill it later
            // If you want to keep shapes for some reason, store them, but for now:
            // We'll rely on "Fill Last Shape" to create an action
          } else if (isDrawingStroke && currentStroke) {
            // Finalize the stroke
            actions.push(currentStroke);
            isDrawingStroke = false;
            currentStroke = null;
            saveHistory();
          }
        }

        function isOnCanvas() {
          return (mouseX >= 0 && mouseX < width && mouseY >= 0 && mouseY < height);
        }

        /******************************************************
         * Text Fill
         ******************************************************/
        function fillLastShape() {
          if (tempShape.length < 3) {
            alert("No valid shape captured. Hold SHIFT and drag to define a shape.");
            return;
          }
          // Create a fillShape action
          let textString = select('#textInput').value() || "@";
          let txtSize = parseInt(select('#textSizeInput').value());
          let spacing = parseInt(select('#textSpacingInput').value());

          let fillAction = {
            type: 'fillShape',
            shape: [...tempShape], // copy of the shape
            text: textString,
            color: brushColor,
            textSize: txtSize,
            spacing: spacing
          };
          actions.push(fillAction);
          tempShape = []; // reset
          saveHistory();
        }

        // Actually fill the shape with repeated text
        function fillShapeWithText(p, shape, textString, fillColor, txtSize, spacing, scaleFactor) {
          p.push();
          p.fill(fillColor);
          p.noStroke();
          p.textSize(txtSize * scaleFactor);

          // bounding box
          let minX = Math.min(...shape.map(pt => pt.x));
          let maxX = Math.max(...shape.map(pt => pt.x));
          let minY = Math.min(...shape.map(pt => pt.y));
          let maxY = Math.max(...shape.map(pt => pt.y));

          for (let y = minY; y < maxY; y += spacing) {
            for (let x = minX; x < maxX; x += spacing) {
              if (pnpoly(shape, x, y)) {
                p.text(textString, x * scaleFactor, y * scaleFactor);
              }
            }
          }

          p.pop();
        }

        // Point in polygon
        function pnpoly(vertices, testx, testy) {
          let c = false;
          for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {
            let xi = vertices[i].x, yi = vertices[i].y;
            let xj = vertices[j].x, yj = vertices[j].y;
            let intersect = ((yi > testy) != (yj > testy)) &&
              (testx < (xj - xi) * (testy - yi) / (yj - yi) + xi);
            if (intersect) c = !c;
          }
          return c;
        }

        /******************************************************
         * Undo/Redo
         ******************************************************/
        function saveHistory() {
          historyIndex++;
          // If we have undone some steps, remove future states
          if (historyIndex < history.length) {
            history.splice(historyIndex);
          }
          // Push a deep copy of actions
          let snapshot = JSON.parse(JSON.stringify(actions));
          history.push(snapshot);
        }

        function undoAction() {
          if (historyIndex > 0) {
            historyIndex--;
            actions = JSON.parse(JSON.stringify(history[historyIndex]));
          }
        }

        function redoAction() {
          if (historyIndex < history.length - 1) {
            historyIndex++;
            actions = JSON.parse(JSON.stringify(history[historyIndex]));
          }
        }

        /******************************************************
         * Project Import / Export (JSON)
         ******************************************************/
        function importProject() {
          let input = createFileInput(handleFile);
          input.elt.click();

          function handleFile(file) {
            if (file.type === 'application' || file.subtype === 'json') {
              let data = JSON.parse(file.data);
              if (!data.actions) {
                alert("Invalid project file.");
                return;
              }
              actions = data.actions;
              history = [];
              historyIndex = -1;
              saveHistory();
            } else {
              alert("Please select a valid project JSON file.");
            }
          }
        }

        function exportProject() {
          let projectData = {
            actions: actions
          };
          let blob = new Blob([JSON.stringify(projectData)], { type: "application/json" });
          let url = URL.createObjectURL(blob);

          let a = createA(url, 'project.json');
          a.elt.download = 'project.json';
          a.elt.click();
        }

        /******************************************************
         * High-Resolution Export
         ******************************************************/
        function exportHighRes(format) {
          if (format === 'tiff') {
            alert("TIFF export not supported in p5.js. Please export as PNG/JPG and convert externally.");
            return;
          }

          // Create an off-screen graphics buffer at EXPORT_SIZE
          let pg = createGraphics(EXPORT_SIZE, EXPORT_SIZE);
          // Avoid extra pixel density
          pg.pixelDensity(1);

          // Scale factor between interactive canvas and export canvas
          let scaleFactor = EXPORT_SIZE / INTERACTIVE_SIZE;

          // Draw all actions at high resolution
          pg.background(255);
          for (let action of actions) {
            drawAction(action, pg, scaleFactor);
          }

          // Convert to data URL
          let mimeType = (format === 'png') ? 'image/png' : 'image/jpeg';
          let dataURL = pg.canvas.toDataURL(mimeType);

          // Trigger download
          let filename = 'myScarfDesign.' + format;
          let a = createA(dataURL, filename);
          a.elt.download = filename;
          a.elt.click();

          // Clean up
          pg.remove();
        }

        /******************************************************
         * UI Setup
         ******************************************************/
        function setupUI() {
          // Color Picker
          select('#colorPicker').changed(() => {
            brushColor = select('#colorPicker').value();
          });

          // Brush Size
          select('#brushSizeSlider').changed(() => {
            brushSize = parseInt(select('#brushSizeSlider').value());
          });

          // Tools
          select('#brushToolBtn').mousePressed(() => {
            currentTool = 'brush';
          });
          select('#eraserToolBtn').mousePressed(() => {
            currentTool = 'eraser';
          });

          // Undo/Redo
          select('#undoBtn').mousePressed(undoAction);
          select('#redoBtn').mousePressed(redoAction);

          // Start New
          select('#startNewBtn').mousePressed(() => {
            let confirmNew = confirm("Start a new project? Unsaved work will be lost.");
            if (confirmNew) {
              actions = [];
              history = [];
              historyIndex = -1;
              background(255);
              saveHistory();
            }
          });

          // Import / Export Project
          select('#importProjectBtn').mousePressed(importProject);
          select('#exportProjectBtn').mousePressed(exportProject);

          // Text Fill
          select('#textFillBtn').mousePressed(fillLastShape);

          // Export Image
          select('#exportPngBtn').mousePressed(() => exportHighRes('png'));
          select('#exportJpgBtn').mousePressed(() => exportHighRes('jpg'));
          select('#exportTiffBtn').mousePressed(() => exportHighRes('tiff'));
        }
      </script>
    </div>
  </body>
</html>
